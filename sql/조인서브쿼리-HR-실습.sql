-- 조인서브쿼리-HR-실습(문제).sql

-- 1) 연봉이 전체평균연봉보다 높은 직원의 정보를 연봉이 많은순으로 조회
--    (연봉=SALARY*12)
-- NVL(SALARY*12, 0) : 연봉이 NULL인 경우(정해지지 않은 경우) 0으로 처리
SELECT NVL(SALARY*12, 0) "연봉", E.*
FROM EMPLOYEES E
WHERE NVL(SALARY*12, 0) > (
	SELECT AVG(NVL(SALARY*12, 0))
	FROM EMPLOYEES
)
ORDER BY NVL(SALARY*12, 0) DESC;

-- 2) 부서별로 연봉을 가장 많이 받는 직원의 정보를 조회
SELECT *
FROM EMPLOYEES
WHERE (DEPARTMENT_ID, NVL(SALARY*12, 0)) IN (
	SELECT DEPARTMENT_ID, MAX(NVL(SALARY*12, 0))
	FROM EMPLOYEES
	GROUP BY DEPARTMENT_ID
);

-- 3) JOB_ID가 SA_REP인 직원들 중에서 입사일이 가장 빠른 직원의 정보를 조회
-- MIN(HIRE_DATE) : 입사일이 가장 빠른
SELECT *
FROM EMPLOYEES
WHERE HIRE_DATE = (
	SELECT MIN(HIRE_DATE)
	FROM EMPLOYEES
	WHERE JOB_ID = 'SA_REP'
);

-- 4) JOB_ID가 S로 시작하는 직원 중 최저월급을 받는 직원의 정보를 조회
SELECT *
FROM EMPLOYEES
WHERE SALARY = (
		SELECT MIN(SALARY)
		FROM EMPLOYEES
		WHERE JOB_ID LIKE 'S%'
	);

-- 5) 직원아이디가 100인 직원과 같은 부서에 근무하는 직원들의
--    직원아이디, 직원명, 부서아이디, 부서명을 조회
SELECT E.EMPLOYEE_ID, E.FIRST_NAME||''||E.LAST_NAME, 
	D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID 
	AND E.DEPARTMENT_ID = (
		SELECT DEPARTMENT_ID 
		FROM EMPLOYEES E2
		WHERE E2.EMPLOYEE_ID = 100
	);

-- 6) 부서명이 S로 시작하는 부서에 근무하는 직원들의
--    직원아이디, 직원명, 부서아이디, 부서명을 조회
SELECT E.EMPLOYEE_ID, E.FIRST_NAME||''||E.LAST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID  = D.DEPARTMENT_ID
	AND D.DEPARTMENT_NAME LIKE 'S%';

-- 7) 직무아이디가 IT_PROG인 직원들 중 최소월급을 받는 사람과
--    최대월급을 받는 사람의 직원아이디, 직원명, 부서명, 월급을 조회
SELECT E.EMPLOYEE_ID, E.FIRST_NAME||''||E.LAST_NAME, D.DEPARTMENT_NAME, E.SALARY, E.JOB_ID 
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
	AND E.SALARY IN (
		SELECT MAX(SALARY)
		FROM EMPLOYEES
		WHERE JOB_ID='IT_PROG'
	)
UNION
SELECT E.EMPLOYEE_ID, E.FIRST_NAME||''||E.LAST_NAME, D.DEPARTMENT_NAME, E.SALARY, E.JOB_ID
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
	AND E.SALARY IN (
		SELECT MIN(SALARY)
		FROM EMPLOYEES
		WHERE JOB_ID='IT_PROG'
	);

-- 8) 모든 직원의 직원아이디, 직원명, 부서명, 커미션이 포함된 월급을 조회
--    (단, 커미션퍼센트가 NULL인 경우는 제외)
SELECT E.EMPLOYEE_ID, E.FIRST_NAME||''||E.LAST_NAME, 
	D.DEPARTMENT_NAME, E.COMMISSION_PCT, E.SALARY + (E.SALARY*E.COMMISSION_PCT) TOTAL
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
	AND E.COMMISSION_PCT IS NOT NULL;

-- 9) 커미션퍼센트가 NULL인 직원들이 근무하는 부서별로
--    부서아이디, 부서명, 부서직원들의 커미션이 포함된 월급의 합계를 조회
--    (단, 커미션퍼센트가 NULL인 경우는 제외)
SELECT E.DEPARTMENT_ID, D.DEPARTMENT_NAME, 
	SUM(E.SALARY + (E.SALARY*E.COMMISSION_PCT))
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
	AND E.COMMISSION_PCT IS NOT NULL
GROUP BY E.DEPARTMENT_ID, D.DEPARTMENT_NAME;

-- 10) 직무수행시간(END_DATE-START_DATE)이 가장 길었던 직무를 수행했던 
--     직원이 근무하는 부서내 직원들의 직무아이디, 직무명, 부서명, 직원아이디, 직원명을 조회
-- 여러개 조인할 때는 JOIN ON이 편함
SELECT JH.JOB_ID, J.JOB_TITLE, D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.FIRST_NAME||''||E.LAST_NAME 
FROM EMPLOYEES E, DEPARTMENTS D, JOB_HISTORY JH, JOBS J
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
	AND D.DEPARTMENT_ID = JH.DEPARTMENT_ID
	AND JH.JOB_ID = J.JOB_ID
	AND (D.DEPARTMENT_ID, END_DATE - START_DATE) = (
		SELECT D.DEPARTMENT_ID, MAX(END_DATE - START_DATE) 
		FROM JOB_HISTORY JH, EMPLOYEES E
		WHERE JH.JOB_ID = E.JOB_ID
	);

-- 11) 시애틀(Seattle)에 있는 부서에 근무하는 모든 직원들의
--     부서아이디, 부서명, 직원아이디, 직원명을 조회
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.FIRST_NAME||''||E.LAST_NAME
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
	AND D.LOCATION_ID = L.LOCATION_ID
	AND L.CITY = 'Seattle';

-- 12) 유럽(Europe)에 있는 도시들에 있는 모든 부서에 근무하는 직원들의
--     도시명, 부서아이디, 부서명, 직원아이디, 직원명을 조회
SELECT R.REGION_NAME, C.COUNTRY_ID, L.CITY, D.DEPARTMENT_ID, 
	D.DEPARTMENT_NAME, E.EMPLOYEE_ID, E.FIRST_NAME||''||E.LAST_NAME
FROM REGIONS R, COUNTRIES C, LOCATIONS L, DEPARTMENTS D, EMPLOYEES E
WHERE R.REGION_ID = C.REGION_ID 
	AND C.COUNTRY_ID = L.COUNTRY_ID
	AND D.LOCATION_ID = L.LOCATION_ID
	AND D.DEPARTMENT_ID = E.DEPARTMENT_ID
	AND R.REGION_NAME='Europe';

-- 13) 입사년도별로 최대급여와 최소급여 받는 직원의 입사년도 네자리, 직원아이디
--     풀네임, 월급을 입사년도 내림차순으로 조회
SELECT TO_CHAR(HIRE_DATE, 'YYYY'), EMPLOYEE_ID, FIRST_NAME||''||LAST_NAME, SALARY
FROM EMPLOYEES
WHERE (TO_CHAR(HIRE_DATE, 'YYYY'), SALARY) IN (
	SELECT TO_CHAR(HIRE_DATE, 'YYYY'), MAX(SALARY)
	FROM EMPLOYEES
	GROUP BY TO_CHAR(HIRE_DATE, 'YYYY')
)
UNION
SELECT TO_CHAR(HIRE_DATE, 'YYYY'), EMPLOYEE_ID, FIRST_NAME||''||LAST_NAME, SALARY
FROM EMPLOYEES
WHERE (TO_CHAR(HIRE_DATE, 'YYYY'), SALARY) IN (
	SELECT TO_CHAR(HIRE_DATE, 'YYYY'), MIN(SALARY)
	FROM EMPLOYEES
	GROUP BY TO_CHAR(HIRE_DATE, 'YYYY')
)
ORDER BY SALARY DESC;

-- 14. 부서가 없는 직원의 풀네임 조회
SELECT FIRST_NAME||' '||LAST_NAME
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NULL;

-- 15. 소속된 직원이 없는 부서명 조회
SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID
	AND E.DEPARTMENT_ID IS NULL;

-- 16. 월급이 부서의 평균월급보다 적은 직원의 풀네임과 월급을 조회
SELECT 
    E.FIRST_NAME || ' ' || E.LAST_NAME AS FULL_NAME,
    E.SALARY
FROM EMPLOYEES E
JOIN (
    SELECT DEPARTMENT_ID, AVG(SALARY) AS AVG_SALARY
    FROM EMPLOYEES
    GROUP BY DEPARTMENT_ID
) D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.SALARY < D.AVG_SALARY
ORDER BY E.DEPARTMENT_ID;


-- 17. 월급이 5000 이상인 직원 중 부서가 없는 직원의 풀네임과 월급을 조회
SELECT FIRST_NAME||' '||LAST_NAME, SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NULL
	AND SALARY = ANY (
			SELECT SALARY
			FROM EMPLOYEES
			WHERE SALARY > 5000
		);


-- 18. 부서가 없는 직원 중 급여가 전체 평균급여보다 높은 직원 풀네임과 월급을 조회
SELECT FIRST_NAME||' '||LAST_NAME, SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID IS NULL
	AND SALARY > (
		SELECT AVG(NVL(SALARY, 0))
		FROM EMPLOYEES
	);

-- 19. 직원이 없는 부서를 포함하여 부서별 직원 수를 조회
SELECT D.DEPARTMENT_ID, COUNT(E.EMPLOYEE_ID)
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_ID;

-- 20. 부서가 없는 직원 중 월급이 7000 이상이고 직책이 'SA_REP'인
--      직원의 풀네임과 월급을 조회
SELECT E.FIRST_NAME||' '||E.LAST_NAME, E.SALARY, E.JOB_ID 
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
	AND E.SALARY > 7000
	AND E.JOB_ID = 'SA_REP';

-- 21. 부서별로 평균 연봉이 가장 높은 부서의 직원에 대해 직원아이디, 풀네임, 부서아이디, 월급 조회
SELECT 
	EMPLOYEE_ID,
	FIRST_NAME||''||LAST_NAME,
	DEPARTMENT_ID,
	SALARY
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (
	SELECT E1.DEPARTMENT_ID
	FROM EMPLOYEES E1
	GROUP BY E1.DEPARTMENT_ID
	HAVING AVG(NVL(E1.SALARY, 0)) = (
		SELECT MAX(AVG_SALARY)
		FROM (
			SELECT AVG(NVL(E2.SALARY, 0)) AVG_SALARY 
			FROM EMPLOYEES E2 
			GROUP BY E2.DEPARTMENT_ID
		)
	)
);


-- 22. 동일 직책 내에서 자신보다 높은 월급을 받는 직원에 대해 직원아이디, 풀네임, 직무아이디, 월급, 
--       높은 월급을 받는 직원의 수 조회
SELECT 
	E1.EMPLOYEE_ID,
	E1.FIRST_NAME||''||E1.LAST_NAME,
	E1.SALARY,
	(
		SELECT COUNT(*)
		FROM EMPLOYEES E2
		WHERE E1.JOB_ID = E2.JOB_ID
			AND E1.SALARY < E2.SALARY
	)
FROM EMPLOYEES E1
WHERE (
	SELECT COUNT(*)
	FROM EMPLOYEES E2
	WHERE E1.JOB_ID = E2.JOB_ID
		AND E1.SALARY < E2.SALARY
) > 0

-- 23. 부서별 월급 합계가 전체 연봉 합계의 10% 이상인 부서에 대해 부서명, 전체월급을 조회
SELECT D.DEPARTMENT_NAME, SUM(NVL(E.SALARY, 0))
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME
HAVING SUM(NVL(E.SALARY, 0)*12) >=
	(SELECT SUM(NVL(E2.SALARY, 0) * 12) * 0.1 FROM EMPLOYEES E2);


-- 24. 자신보다 입사일이 빠른 직원에 대해 직원아이디, 풀네임, 입사일, 직원의 수를 조회
SELECT 
	E1.EMPLOYEE_ID, 
	E1.FIRST_NAME||''||E1.LAST_NAME, 
	E1.HIRE_DATE,
	(
		SELECT COUNT(*)
		FROM EMPLOYEES E2
		WHERE E2.HIRE_DATE < E1.HIRE_DATE
	)
FROM EMPLOYEES E1;

-- 25. 동일 부서 내에서 월급 순위(RANK)가 3위인 직원 정보 조회 (RANK 함수 사용)
SELECT *
FROM (
	SELECT
		EMPLOYEE_ID,
        FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME,
        DEPARTMENT_ID,
        SALARY,
		RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) SALARY_RANK 
	FROM EMPLOYEES
)
WHERE SALARY_RANK = 3;


-- 26. 부서별 평균 월급이 전체 평균월급보다 높은 부서에 근무하는 직원에 대해
--      부서아이디, 소수점둘째자리에서반올림한월급, 부서별직원수를 조회
SELECT 
    E.DEPARTMENT_ID,
    ROUND(NVL(E.SALARY, 0), 2),
    COUNT(*) OVER (PARTITION BY E.DEPARTMENT_ID) AS DEPARTMENT_COUNT
FROM EMPLOYEES E
WHERE E.DEPARTMENT_ID IN (
    SELECT DEPARTMENT_ID
    FROM EMPLOYEES
    GROUP BY DEPARTMENT_ID
    HAVING AVG(SALARY) > (SELECT AVG(SALARY) FROM EMPLOYEES)
)
ORDER BY E.DEPARTMENT_ID;
	
-- 27. WITH 절을 활용하여 부서별 평균 월급을 기준으로 상위/하위 구분하여
--     부서아이디, 부서평균월급, '상위' 또는 '하위' 조회
WITH 
	DEPARTMENT_AVG AS (
		SELECT DEPARTMENT_ID, AVG(SALARY) AVG_SALARY
		FROM EMPLOYEES
		GROUP BY DEPARTMENT_ID
	)
SELECT 
	DEPARTMENT_ID,
	AVG_SALARY,
	CASE 
		WHEN AVG_SALARY >= (SELECT AVG(SALARY) FROM EMPLOYEES) THEN '상위'
		ELSE '하위'
	END
FROM DEPARTMENT_AVG 
ORDER BY DEPARTMENT_ID;

-- 28. 최근 3개월 내 입사자들의 부서아이디, 부서별 입사자수 조회
SELECT 
	DEPARTMENT_ID,
	COUNT(*)
FROM EMPLOYEES
WHERE HIRE_DATE >= ADD_MONTHS(SYSDATE, -3)
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;

-- 29. 부서별 최고 연봉자와 최저 연봉자 정보 조회 (RANK 함수 사용)
SELECT *
FROM (
	SELECT
		EMPLOYEE_ID,
	    FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME,
	    DEPARTMENT_ID,
	    SALARY,
		RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) SALARY_RANK_DESC,
		RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY ASC) SALARY_RANK_ASC
	FROM EMPLOYEES
)
WHERE SALARY_RANK_DESC = 1 OR SALARY_RANK_ASC = 1

-- 30. 자신의 부서 평균월급보다 높은 월급을 받는 직원에 대해 직원아이디, 풀네임, 월급, 
--      부서아이디, '부서 평균 이상' 또는 '부서 평균 이하' 조회 (CASE 문 사용)
SELECT 
	EMPLOYEE_ID, 
	FIRST_NAME||''||LAST_NAME, 
	SALARY,
	DEPARTMENT_ID,
	CASE 
		WHEN SALARY >= AVG(NVL(SALARY, 0)) OVER (PARTITION BY DEPARTMENT_ID) THEN '부서 평균 이상'
		ELSE '부서 평균 이하'	
	END
FROM EMPLOYEES;






























