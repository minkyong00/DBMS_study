-- 레코드&컬렉션-HR-실습.sql

-- 1) 사원번호 100번의 풀네임, 이메일, 급여를 RECDRD에 저장 후 출력
DECLARE
	TYPE REC_EMP IS RECORD (
		EMP_FULLNAME VARCHAR2(46),
		EMP_EMAIL EMPLOYEES.EMAIL%TYPE,
		EMP_SALARY EMPLOYEES.SALARY%TYPE
	);
	V_REC_EMP REC_EMP;
BEGIN
	SELECT FIRST_NAME||' '||LAST_NAME, EMAIL, SALARY
	INTO V_REC_EMP
	FROM EMPLOYEES
	WHERE EMPLOYEE_ID=100;
	PL(V_REC_EMP.EMP_FULLNAME||' '||V_REC_EMP.EMP_EMAIL||' '||V_REC_EMP.EMP_SALARY);
END;

-- 2) 60번 부서에 근무하는 사원들의 급여를 중첩테이블에 저장하고 평균을 구해 출력
DECLARE
	TYPE NT_EMP IS TABLE OF EMPLOYEES%ROWTYPE;
	V_NT_EMP NT_EMP;
	V_NT_SALARY_SUM NUMBER := 0;
BEGIN
	V_NT_EMP := NT_EMP();
	FOR EACHROW IN (SELECT * FROM EMPLOYEES WHERE DEPARTMENT_ID=60)
	LOOP
		V_NT_EMP.EXTEND;
		V_NT_EMP(V_NT_EMP.LAST) := EACHROW;
		V_NT_SALARY_SUM := V_NT_SALARY_SUM + V_NT_EMP(V_NT_EMP.LAST).SALARY;
	END LOOP;
	PL('급여 평균: '||V_NT_SALARY_SUM / 5);
END;

DECLARE
	TYPE NT_SALARY IS TABLE OF NUMBER;
	V_NT_SALARY NT_SALARY := NT_SALARY();
	V_NT_SALARY_SUM NUMBER := 0;
BEGIN
	FOR EACHROW IN (SELECT SALARY FROM EMPLOYEES WHERE DEPARTMENT_ID=60)
	LOOP
		V_NT_SALARY.EXTEND;
		V_NT_SALARY(V_NT_SALARY.COUNT) := EACHROW.SALARY;
		V_NT_SALARY_SUM := V_NT_SALARY_SUM + V_NT_SALARY(V_NT_SALARY.COUNT);
	END LOOP;
	IF V_NT_SALARY.COUNT > 0 THEN
		PL('급여 평균: '||ROUND(V_NT_SALARY_SUM/V_NT_SALARY.COUNT, 2);
	ELSE
		PL('해당 부서의 사원이 없음!');
	END IF;
END;

-- 3) 부서번호를 키로, 부서명을 값으로 하는 연관 배열을 구성하고 90번 부서의 부서명을 출력
DECLARE
	TYPE AA_DEP_NAME IS TABLE OF DEPARTMENTS%ROWTYPE
	INDEX BY PLS_INTEGER;
	V_AA_DEP_NAME AA_DEP_NAME;
	V_DEPARTMENT_ID NUMBER;
BEGIN
	FOR EACHROW IN (SELECT * FROM DEPARTMENTS
					WHERE DEPARTMENT_ID=90)
	LOOP	
		V_DEPARTMENT_ID := EACHROW.DEPARTMENT_ID;
		V_AA_DEP_NAME(V_DEPARTMENT_ID) := EACHROW;
		PL(V_AA_DEP_NAME(V_DEPARTMENT_ID).DEPARTMENT_NAME);
	END LOOP;
END;


-- 4) 사원ID가 102 이하인 사원 3명의 사원ID와 풀네임을 
--     RECORD와 중첩테이블에 저장하고 사원ID와 풀네임을 출력
DECLARE
	TYPE NT_EMP IS TABLE OF EMPLOYEES%ROWTYPE;
	V_NT_EMP NT_EMP;
	CURSOR CUR_EMP_ID100TO102 IS (
		SELECT * FROM EMPLOYEES 
		WHERE EMPLOYEE_ID=100 OR EMPLOYEE_ID=101 OR EMPLOYEE_ID=102 
	);
BEGIN
	V_NT_EMP := NT_EMP();
	FOR EACHROW IN CUR_EMP_ID100TO102
	LOOP
		V_NT_EMP.EXTEND;
		V_NT_EMP(V_NT_EMP.LAST) := EACHROW;
		PL(
			V_NT_EMP(V_NT_EMP.LAST).EMPLOYEE_ID||' '||
			V_NT_EMP(V_NT_EMP.LAST).FIRST_NAME||' '||V_NT_EMP(V_NT_EMP.LAST).LAST_NAME
		);
	END LOOP;
END;

-- 5) 중첩 RECORD를 사용하여 100번 직원의 풀네임과 부서아이디, 부서명을 출력
DECLARE
	TYPE REC_EMP IS RECORD (
		EMP_FULLNAME VARCHAR2(46)
	);
	TYPE REC_DEPT IS RECORD (
		DEPT_ID DEPARTMENTS.DEPARTMENT_ID%TYPE,
		DEPT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE,
		V_REC_EMP REC_EMP
	);
	V_REC_DEPT REC_DEPT;
BEGIN
	SELECT 
		E.FIRST_NAME||' '||E.LAST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
	INTO 
		V_REC_DEPT.V_REC_EMP.EMP_FULLNAME, V_REC_DEPT.DEPT_ID, V_REC_DEPT.DEPT_NAME
	FROM EMPLOYEES E, DEPARTMENTS D
	WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
		AND E.EMPLOYEE_ID = 100;
	PL(V_REC_DEPT.V_REC_EMP.EMP_FULLNAME);
	PL(V_REC_DEPT.DEPT_ID);
	PL(V_REC_DEPT.DEPT_NAME);
END;

-- 6) JOBS테이블에서 JOB_ID를 키로, JOB_TITLE을 값으로 하는 연관배열을 생성하고
--     JOB_ID가 'SA_REP'인 직무의 직무명을 출력
DECLARE
	TYPE AA_JOB IS TABLE OF JOBS%ROWTYPE
	INDEX BY VARCHAR2(46);
	V_AA_JOB AA_JOB;
	V_JOB_ID VARCHAR2(10);
BEGIN
	FOR EACHROW IN (SELECT * FROM JOBS WHERE JOB_ID='SA_REP')
	LOOP
		V_JOB_ID := EACHROW.JOB_ID;
		V_AA_JOB(V_JOB_ID) := EACHROW;
		PL(V_AA_JOB(V_JOB_ID).JOB_TITLE);
	END LOOP;
END;

-- 7) 부서별 사원수를 연관배열을 사용해 저장한 후 90번 부서의 사원수를 출력
DECLARE
	TYPE AA_EMP IS TABLE OF NUMBER
	INDEX BY PLS_INTEGER;
	V_AA_EMP AA_EMP;
	V_EMP_COUNT NUMBER;
BEGIN
	FOR EACHROW IN (
		SELECT COUNT(*) AS EMPCOUNT
		FROM EMPLOYEES 
		WHERE DEPARTMENT_ID=90
		GROUP BY DEPARTMENT_ID 
	)
	LOOP
		V_EMP_COUNT := EACHROW.EMPCOUNT;
		V_AA_EMP(V_EMP_COUNT) := EACHROW;
	END LOOP;
	IF V_AA_EMP.EXISTS(90) THEN
		PL(TO_CHAR(V_AA_EMP(V_EMP_COUNT)));
	ELSE
		PL('해당 부서 없음');
	END IF;
END;


















