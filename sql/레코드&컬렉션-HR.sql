-- 레코드&컬렉션-HR.sql

-- Record (레코드) : 서로 다른 타입들을 하나로 묶은 타입
-- 일반적으로 테이블이나 조인결과의 전체나 일부 컬럼들의 타입을 하나로 묶기 위해서 사용
-- %ROWTYPE : 테이블의 한 행에 있는 모든 컬럼의 타입을 묶은 시스템 레코드타입
-- 구문 형식
-- TYPE 레코드타입명 IS RECORD (
--	  변수명 변수타입,
--	  변수명 변수타입,
--	  변수명 변수타입,
--    ...
-- );

DECLARE
	-- 레코드 타입 선언
	TYPE REC_DEPT IS RECORD (
		DEPT_ID DEPARTMENTS.DEPARTMENT_ID%TYPE,
		DEPT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE
	);
	V_REC_DEPT REC_DEPT; -- 레코드타입 변수 선언
BEGIN
	SELECT DEPARTMENT_ID, DEPARTMENT_NAME
	INTO V_REC_DEPT.DEPT_ID, V_REC_DEPT.DEPT_NAME
	FROM DEPARTMENTS
	WHERE DEPARTMENT_ID=100;
	PL(V_REC_DEPT.DEPT_ID||' '||V_REC_DEPT.DEPT_NAME);
END;

-- RECORD타입에 RECORD타입을 포함 (중첩 레코드)
DECLARE
	TYPE REC_EMP IS RECORD(
		EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE,
		EMP_FULLNAME VARCHAR2(46)
	);
	TYPE REC_DEPT IS RECORD(
		DEPT_ID DEPARTMENTS.DEPARTMENT_ID%TYPE,
		DEPT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE,
		V_REC_EMP REC_EMP -- 레코드 타입 변수
	);
	V_REC_DEPT REC_DEPT;
BEGIN
	SELECT 
		D.DEPARTMENT_ID, D.DEPARTMENT_NAME,
		E.EMPLOYEE_ID, E.FIRST_NAME||' '||E.LAST_NAME
	INTO 
		V_REC_DEPT.DEPT_ID,
		V_REC_DEPT.DEPT_NAME,
		V_REC_DEPT.V_REC_EMP.EMP_ID,
		V_REC_DEPT.V_REC_EMP.EMP_FULLNAME
	FROM EMPLOYEES E, DEPARTMENTS D
	WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
		AND E.EMPLOYEE_ID=110;
	PL(V_REC_DEPT.DEPT_ID);
	PL(V_REC_DEPT.DEPT_NAME);
	PL(V_REC_DEPT.V_REC_EMP.EMP_ID);
	PL(V_REC_DEPT.V_REC_EMP.EMP_FULLNAME);
END;


-- COLLECTION (컬렉션)
-- 동일한 타입의 값을 여러개 묶어서 사용할 목적의 복합 타입
-- 실무에서는 컬렉션내에 레코드들을 담아서 많이 사용
-- 컬렉션 종류
-- 1) 연관 배열 (ASSOCIATIVE ARRAY) : 숫자나 문자를 키로 하고 키마다 값을 매핑해 놓은 타입
-- 2) 중첩 테이블 (NESTED TABLE) : 숫자만 키로 하고 키마다 값을 매핑해 놓은 타입
-- 3) VARRAY : 동일한 타입의 값들을 모아놓은 타입 (LIKE 배열)

-- 연관배열
DECLARE
	-- 정수를 인덱스로 사용하는 VARCHAR2(20)타입들을 묶은 연관배열 타입
	TYPE AA_STRING IS TABLE OF VARCHAR2(20)
	INDEX BY PLS_INTEGER;
	-- 연관배열 타입의 변수 선언
	V_AA_STRING AA_STRING;
BEGIN
	V_AA_STRING(1) := '홍길동';
	V_AA_STRING(2) := '강감찬';
	V_AA_STRING(3) := '이순신';
	PL(V_AA_STRING(1));
	PL(V_AA_STRING(2));
	PL(V_AA_STRING(3));
END;

-- RECORD들의 연관배열
DECLARE
	-- 정수를 키로 하는 DEPARTMENTS테이블의 행들을 저장하는 연관배열
	TYPE AA_DEPT IS TABLE OF DEPARTMENTS%ROWTYPE
	INDEX BY PLS_INTEGER;
	-- 연관배열 타입의 변수 선언
	V_AA_DEPT AA_DEPT;
	-- 레코드 타입의 변수 선언
	V_DEPT50 DEPARTMENTS%ROWTYPE;
	V_DEPT60 DEPARTMENTS%ROWTYPE;
BEGIN
	SELECT * INTO V_DEPT50 FROM DEPARTMENTS WHERE DEPARTMENT_ID=50;
	SELECT * INTO V_DEPT60 FROM DEPARTMENTS WHERE DEPARTMENT_ID=60;
	V_AA_DEPT(1) := V_DEPT50;
	V_AA_DEPT(2) := V_DEPT60;
	PL(V_AA_DEPT(1).DEPARTMENT_ID||' '||V_AA_DEPT(1).DEPARTMENT_NAME);
	PL(V_AA_DEPT(2).DEPARTMENT_ID||' '||V_AA_DEPT(2).DEPARTMENT_NAME);
END;

-- EMPLOYEES테이블의 사원 풀네임을 키로 하고 행을 값으로 하는 연관배열
DECLARE
	TYPE AA_EMP IS TABLE OF EMPLOYEES%ROWTYPE
	INDEX BY VARCHAR2(46);
	V_AA_EMP AA_EMP;
	-- SELECT를 통해 조회된 행들을 가리키는 커서
	CURSOR CUR_EMP IS (
		SELECT * FROM EMPLOYEES
	);
	V_FULLNAME VARCHAR2(46);
BEGIN
	FOR EACHROW IN CUR_EMP
	LOOP
		V_FULLNAME := EACHROW.FIRST_NAME||' '||EACHROW.LAST_NAME;
		V_AA_EMP(V_FULLNAME) := EACHROW; -- 키가 풀네임, 값이 행
		PL(V_AA_EMP(V_FULLNAME).FIRST_NAME);
		PL(V_AA_EMP(V_FULLNAME).SALARY);
	END LOOP;
END;


-- 중첩 테이블
-- 인덱스가 없음 내부적으로 숫자로 선언
DECLARE
	-- 중첩테이블 타입 선언
	TYPE NT_EMP IS TABLE OF EMPLOYEES%ROWTYPE;
	-- 중첩테이블 타입의 변수 선언
	V_NT_EMP NT_EMP;
BEGIN
	-- 비어있는 중첩테이블 생성
	V_NT_EMP := NT_EMP();
	-- EMPLOYEES 행의 수 만큼 반복
	FOR EACHROW IN (SELECT * FROM EMPLOYEES) -- 익명 커서
	LOOP
		-- 중첩테이블에 공간 추가
		V_NT_EMP.EXTEND;
		V_NT_EMP(V_NT_EMP.LAST) := EACHROW;
		PL(
			V_NT_EMP(V_NT_EMP.LAST).EMPLOYEE_ID||' '||
			V_NT_EMP(V_NT_EMP.LAST).FIRST_NAME||' '||
			V_NT_EMP(V_NT_EMP.LAST).LAST_NAME||' '||
			V_NT_EMP(V_NT_EMP.LAST).SALARY
		);
	END LOOP;
END;

-- VARRAY
-- 동일한 타입의 여러값을 저장하는 타입 (LIKE 배열)
DECLARE
	-- DEPARTMENSTS 테이블의 DEPARTMENT_NAME컬럼 타입의 값을 100개 저장 가능한 VARRAY타입
	TYPE VA_NAME IS VARRAY(100)
	OF DEPARTMENTS.DEPARTMENT_NAME%TYPE;
	-- VARRAY 타입의 변수 선언
	V_VA_NAME VA_NAME;
BEGIN
	-- 비어있는 VARRAY 생성
	V_VA_NAME := VA_NAME();
	FOR EACHROW IN (SELECT * FROM DEPARTMENTS)
	LOOP
		-- VARRAY 공간 추가
		V_VA_NAME.EXTEND;
		V_VA_NAME(V_VA_NAME.LAST) := EACHROW.DEPARTMENT_NAME;
		PL(V_VA_NAME(V_VA_NAME.LAST));
	END LOOP;
END;






































